<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Adjustable Snake RL — Minimal Sandbox (Split Penalties, 95% Scale, Clean Overlays)</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f1730; --ink:#e8eefc; --muted:#a9b5e6; --accent:#7ee787; --danger:#ff7b72; --grid:#172449; --fruit:#ffd166;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{position:fixed; inset:0; display:grid; grid-template-columns:minmax(260px, 340px) 1fr; min-height:100vh}
  aside{background:var(--panel); border-right:1px solid #16224a; padding:14px 12px; overflow:auto}
  main{display:grid; grid-template-rows:auto 1fr; min-width:0}
  header{display:flex; gap:8px; align-items:center; padding:10px 12px; border-bottom:1px solid #16224a}
  h1{font-size:16px; margin:0; letter-spacing:.2px}
  .row{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; margin:8px 0}
  .row label{color:var(--muted); cursor:pointer}
  input[type="range"]{width:100%}
  input[type="number"]{width:100px; background:#0d142d; border:1px solid #1c2b58; color:var(--ink); border-radius:6px; padding:6px}
  input[type="checkbox"]{transform:scale(1.1)}
  .row input[type="checkbox"]{ justify-self:end }
  .section{margin:14px 0 10px; padding-top:6px; border-top:1px dashed #1c2b58}
  .section h3{margin:8px 0 6px; font-size:13px; color:#c9d6ff; letter-spacing:.3px; text-transform:uppercase}
  .pill{padding:6px 10px; background:#0d142d; border:1px solid #1c2b58; border-radius:999px}
  button{background:#182653; color:var(--ink); border:1px solid #27408f; padding:8px 10px; border-radius:8px; cursor:pointer}
  button:hover{filter:brightness(1.07)}
  #stats{display:flex; gap:10px; flex-wrap:wrap}
  canvas{display:block; width:100%; height:100%; background:#0a142e}
  .small{font-size:12px; color:var(--muted)}
  .kv{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
</style>
</head>
<body>
<div id="wrap">
  <aside>
    <h2 style="margin:0 0 6px">Controls</h2>
    <div class="small">Adjust live while training runs.</div>

    <div class="section"><h3>Environment</h3>
      <div class="row">
        <label for="w">Board W×H</label>
        <div class="kv">
          <input id="w" type="number" min="5" max="40" step="1" value="15" />
          <input id="h" type="number" min="5" max="40" step="1" value="15" />
        </div>
      </div>
      <div class="row">
        <label for="maxSteps">Max steps/episode</label>
        <input id="maxSteps" type="number" min="50" step="10" value="500" />
      </div>
      <div class="row">
        <label for="speed">Speed (steps/sec)</label>
        <input id="speed" type="range" min="1" max="60" value="20" />
      </div>
      <div class="row" style="margin-top:-6px;">
        <span></span><span id="speedVal" class="small">20</span>
      </div>
      <div class="section"><h3>Collisions</h3>
        <div class="row">
          <label for="wallsKill">Walls kill (no wrap)</label>
          <input id="wallsKill" type="checkbox">
        </div>
      </div>
    </div>

    <div class="section"><h3>Rewards</h3>
      <div class="row"><label for="rFruit">Fruit reward</label><input id="rFruit" type="number" step="0.01" value="1.0"></div>
      <div class="row"><label for="rDeathSelf">Death penalty (self)</label><input id="rDeathSelf" type="number" step="0.01" value="-1.0"></div>
      <div class="row"><label for="rDeathWall">Death penalty (wall)</label><input id="rDeathWall" type="number" step="0.01" value="-1.0"></div>
      <div class="row"><label for="rStep">Step (living) reward</label><input id="rStep" type="number" step="0.001" value="-0.01"></div>
      <div class="row"><label for="rDist">Distance shaping</label><input id="rDist" type="number" step="0.001" value="0.003"></div>
      <div class="row"><label for="rStraight">Straightness bonus</label><input id="rStraight" type="number" step="0.001" value="0.001"></div>
      <div class="row"><label for="starveSteps">Starve steps</label><input id="starveSteps" type="number" min="10" step="10" value="150"></div>
      <div class="small">Timeouts apply a mild penalty = 0.25 × min(self, wall).</div>
    </div>

    <div class="section"><h3>Algorithm (Q-learning)</h3>
      <div class="row"><label for="alpha">Learning rate α</label><input id="alpha" type="number" step="0.0001" value="0.001"></div>
      <div class="row"><label for="gamma">Discount γ</label><input id="gamma" type="number" step="0.01" value="0.99"></div>
      <div class="row"><label for="epsStart">ε start → end</label>
        <div class="kv">
          <input id="epsStart" type="number" step="0.01" value="1.0">
          <input id="epsEnd" type="number" step="0.01" value="0.05">
        </div>
      </div>
      <div class="row"><label for="epsDecay">ε decay steps</label><input id="epsDecay" type="number" step="100" value="100000"></div>
      <div class="row"><label for="clip">Reward clip (|r|≤1)</label><input id="clip" type="checkbox" checked></div>
    </div>

    <div class="section"><h3>Run control</h3>
      <div class="row">
        <div class="kv">
          <button id="btnRun">Run</button>
          <button id="btnPause">Pause</button>
          <button id="btnStep">Step</button>
          <button id="btnReset">Reset</button>
        </div>
        <button id="btnDefaults">Defaults</button>
      </div>
      <div class="row">
        <label for="seed">Seed</label>
        <input id="seed" type="number" step="1" value="0">
      </div>
    </div>

    <div class="section"><h3>Overlays</h3>
      <div class="row"><label for="showSensors">Show sensors</label><input id="showSensors" type="checkbox" checked></div>
    </div>

    <div class="section small">
      State = [dangerLeft, dangerFront, dangerRight, dir(4), fruitQuadrant(4)] • Actions = turnLeft / straight / turnRight
    </div>
  </aside>

  <main>
    <header>
      <h1>Adjustable Snake RL</h1>
      <div id="stats">
        <span class="pill">Ep: <b id="ep">0</b></span>
        <span class="pill">Step: <b id="step">0</b></span>
        <span class="pill">Len: <b id="len">0</b></span>
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">ε: <b id="eps">1.00</b></span>
        <span class="pill">R/Ep (100-avg): <b id="avgR">0.00</b></span>
        <span class="pill">SPS: <b id="sps">0</b></span>
        <span class="pill">Last end: <b id="lastEnd">—</b></span>
      </div>
    </header>
    <canvas id="cv"></canvas>
  </main>
</div>

<script>
(() => {
  const ids = Object.fromEntries([...document.querySelectorAll('[id]')].map(n=>[n.id,n]));

  // keep the speed value label in sync
  ids.speed.addEventListener('input', () => { ids.speedVal.textContent = ids.speed.value; });

  const CV = ids.cv;
  const CTX = CV.getContext('2d');
  let running=false, timer=null, lastTick=0, acc=0, stepsThisSecond=0, sps=0, lastSpsT=0;

  // ---------- Utils / RNG ----------
  function xorshift(seed){
    let x = (seed|0) || 1;
    return () => { x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; };
  }
  const DIRS = [[1,0],[0,1],[-1,0],[0,-1]]; // R,D,L,U
  const ACTS = [-1,0,1]; // L, S, R relative
  function clamp(n,a,b){ return Math.max(a,Math.min(b,n)); }

  // ---------- Config ----------
  function readConfig(){
    return {
      W: clamp(parseInt(ids.w.value)||15,5,60),
      H: clamp(parseInt(ids.h.value)||15,5,60),
      wrap: !ids.wallsKill.checked, // checked => walls kill
      maxSteps: parseInt(ids.maxSteps.value)||500,
      speed: clamp(parseInt(ids.speed.value)||20,1,120),
      rFruit: parseFloat(ids.rFruit.value)||0,
      rDeathSelf: parseFloat(ids.rDeathSelf.value)||0,
      rDeathWall: parseFloat(ids.rDeathWall.value)||0,
      rStep: parseFloat(ids.rStep.value)||0,
      rDist: parseFloat(ids.rDist.value)||0,
      rStraight: parseFloat(ids.rStraight.value)||0,
      starveSteps: parseInt(ids.starveSteps.value)||150,
      alpha: parseFloat(ids.alpha.value)||0.001,
      gamma: parseFloat(ids.gamma.value)||0.99,
      epsStart: parseFloat(ids.epsStart.value)||1.0,
      epsEnd: parseFloat(ids.epsEnd.value)||0.05,
      epsDecay: parseInt(ids.epsDecay.value)||100000,
      clip: ids.clip.checked,
      seed: parseInt(ids.seed.value)||0,
      showSensors: ids.showSensors.checked,
    };
  }
  function setDefaults(){
    ids.w.value=15; ids.h.value=15; ids.wallsKill.checked=false; // default: wrap on
    ids.maxSteps.value=500; ids.speed.value=20; ids.speedVal.textContent='20';
    ids.rFruit.value=1.0; ids.rDeathSelf.value=-1.0; ids.rDeathWall.value=-1.0;
    ids.rStep.value=-0.01; ids.rDist.value=0.003; ids.rStraight.value=0.001;
    ids.starveSteps.value=150;
    ids.alpha.value=0.001; ids.gamma.value=0.99;
    ids.epsStart.value=1.0; ids.epsEnd.value=0.05; ids.epsDecay.value=100000;
    ids.clip.checked=true; ids.seed.value=0;
    ids.showSensors.checked=true;
  }

  // ---------- Environment ----------
  class SnakeEnv{
    constructor(cfg){ this.cfg = cfg; this.rng = xorshift(cfg.seed||1); this.reset(); }
    reset(){
      const {W,H} = this.cfg;
      this.dir = 0; // start moving right
      const cx = (W/2|0), cy = (H/2|0);
      this.snake = [{x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy}];
      this.alive = true;
      this.steps = 0;
      this.score = 0;
      this.starve = 0;
      this.lastEndCause = '—';
      this.spawnFruit();
      this.lastDist = this.manhattan(this.head(), this.fruit);
      return this.observe();
    }
    head(){ return this.snake[0]; }
    spawnFruit(){
      const {W,H} = this.cfg;
      while(true){
        const fx = (this.rng()*W|0), fy=(this.rng()*H|0);
        if (!this.snake.some(s=>s.x===fx&&s.y===fy)){ this.fruit={x:fx,y:fy}; return; }
      }
    }
    manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }
    turn(action){ this.dir = (this.dir + (action===-1?3:action===1?1:0)) & 3; }
    wrapCoord(n, max){ return (n+max)%max; }
    collide(x,y){
      const {W,H,wrap} = this.cfg;
      if (!wrap){
        if (x<0||y<0||x>=W||y>=H) return 'wall';
      }
      const hx = wrap? this.wrapCoord(x,W) : x;
      const hy = wrap? this.wrapCoord(y,H) : y;
      if (this.snake.some((s,i)=>i>0 && s.x===hx && s.y===hy)) return 'self';
      return null;
    }
    step(action){
      const C = this.cfg;
      if (!this.alive) return {obs:this.observe(), reward:0, done:true, info:{}};
      this.turn(action);
      const [dx,dy] = DIRS[this.dir];
      let nx = this.head().x + dx, ny = this.head().y + dy;
      if (C.wrap){ nx=this.wrapCoord(nx,C.W); ny=this.wrapCoord(ny,C.H); }
      const hit = this.collide(nx,ny);
      let reward = C.rStep;

      // distance shaping
      const newDist = this.manhattan({x: (C.wrap?this.wrapCoord(nx,C.W):nx), y:(C.wrap?this.wrapCoord(ny,C.H):ny)}, this.fruit);
      reward += C.rDist * (this.lastDist - newDist);
      this.lastDist = newDist;

      // straightness bonus
      if (action===0) reward += C.rStraight;

      if (hit){
        this.alive = false;
        reward += (hit==='self' ? C.rDeathSelf : C.rDeathWall);
        this.lastEndCause = hit;
        return {obs:this.observe(), reward:this.clip(reward), done:true, info:{death:hit}};
      }

      // move snake
      this.snake.unshift({x:(C.wrap?this.wrapCoord(nx,C.W):nx), y:(C.wrap?this.wrapCoord(ny,C.H):ny)});

      // did we eat?
      let ate=false;
      if (this.head().x===this.fruit.x && this.head().y===this.fruit.y){
        reward += C.rFruit;
        this.score += 1;
        ate=true; this.starve=0;
        this.spawnFruit();
        this.lastDist = this.manhattan(this.head(), this.fruit);
      }

      if (!ate){ this.snake.pop(); this.starve++; }
      this.steps++;

      // --- timeout/starve handling (do NOT end episode on the same tick as eating) ---
      let doneTimeout = (!this.alive) || (this.steps>=C.maxSteps) || (this.starve>=C.starveSteps);
      if (ate) doneTimeout = false; // grace on the eat tick
      if (doneTimeout){
        this.alive=false;
        this.lastEndCause = (this.steps>=C.maxSteps) ? 'maxSteps' : (this.starve>=C.starveSteps ? 'starve' : 'dead');
        const mild = 0.25 * Math.min(C.rDeathSelf, C.rDeathWall); // both negative by default
        reward += mild;
      }

      return {obs:this.observe(), reward:this.clip(reward), done:(!this.alive), info:{}};
    }
    clip(r){ return this.cfg.clip ? Math.max(-1,Math.min(1,r)) : r; }

    // Observation: 3 danger bits (L,F,R), dir 0..3, fruit quadrant 0..3 relative to head
    observe(){
      const h = this.head(), {W,H,wrap} = this.cfg;
      const [dx,dy] = DIRS[this.dir];
      // Forward
      const dangerF = (this.collide(h.x+dx,h.y+dy) !== null);
      // Left
      const ldir = (this.dir+3)&3; const [ldx,ldy]=DIRS[ldir];
      const dangerL = (this.collide(h.x+ldx,h.y+ldy) !== null);
      // Right
      const rdir=(this.dir+1)&3; const [rdx,rdy]=DIRS[rdir];
      const dangerR = (this.collide(h.x+rdx,h.y+rdy) !== null);

      // Fruit relative (wrap-aware shortest displacement)
      let rx = this.fruit.x - h.x, ry = this.fruit.y - h.y;
      if (wrap){
        rx = ((rx%W)+W)%W; if (rx>W/2) rx-=W;
        ry = ((ry%H)+H)%H; if (ry>H/2) ry-=H;
      }
      // Rotate into egocentric frame
      const rot = (p,dir)=>{
        if (dir===0) return p;
        if (dir===1) return {x:p.y, y:-p.x};
        if (dir===2) return {x:-p.x, y:-p.y};
        return {x:-p.y, y:p.x};
      };
      const eg = rot({x:rx,y:ry}, this.dir);
      const fq = (eg.x>=0 && eg.y<0)?0 : (eg.x<0 && eg.y<0)?1 : (eg.x<0 && eg.y>=0)?2 : 3;
      return {dangerL:+dangerL, dangerF:+dangerF, dangerR:+dangerR, dir:this.dir, fq};
    }

    // Rendering (HiDPI & ~95% scale of available host to avoid clipping)
    draw(){
      const {W,H,showSensors} = this.cfg;

      const dpr = Math.max(1, window.devicePixelRatio||1);
      const SCALE = 0.95;
      const pad = 20;

      const host = CV.parentElement || document.body;
      const rect = host.getBoundingClientRect();
      const availW = Math.max(10, rect.width * SCALE) | 0;
      const availH = Math.max(10, rect.height * SCALE) | 0;

      const cell = Math.floor(Math.min((availW-2*pad)/W, (availH-2*pad)/H));
      const width = cell*W + 2*pad;
      const height = cell*H + 2*pad;

      if (CV.width !== width*dpr || CV.height !== height*dpr){
        CV.width = width*dpr;
        CV.height = height*dpr;
        CV.style.width = width + 'px';
        CV.style.height = height + 'px';
      }

      CTX.setTransform(dpr,0,0,dpr,0,0);
      CTX.clearRect(0,0,width,height);
      CTX.fillStyle='#081029';
      CTX.fillRect(0,0,width,height);

      CTX.save();
      CTX.translate(pad,pad);

      // grid
      for(let y=0;y<H;y++){
        for(let x=0;x<W;x++){
          CTX.fillStyle = ((x+y)&1)? '#0d1a3a' : '#0c1734';
          CTX.fillRect(x*cell,y*cell,cell,cell);
        }
      }

      // fruit
      CTX.fillStyle= '#ffd166';
      roundRect(CTX, this.fruit.x*cell+2, this.fruit.y*cell+2, cell-4, cell-4, 4);
      CTX.fill();

      // snake
      for(let i=this.snake.length-1;i>=0;i--){
        const s=this.snake[i];
        CTX.fillStyle = (i===0)? '#7ee787' : '#61a672';
        roundRect(CTX, s.x*cell+1, s.y*cell+1, cell-2, cell-2, 5);
        CTX.fill();
      }

      // sensors (optional)
      if (showSensors){
        const h = this.head();
        const ldir=(this.dir+3)&3, rdir=(this.dir+1)&3;
        const ray = (dir, a) => {
          CTX.strokeStyle=`rgba(255,255,255,${a})`; CTX.lineWidth=2; CTX.beginPath();
          CTX.moveTo((h.x+0.5)*cell,(h.y+0.5)*cell);
          CTX.lineTo((h.x+0.5+DIRS[dir][0])*cell,(h.y+0.5+DIRS[dir][1])*cell);
          CTX.stroke();
        };
        ray(this.dir,0.6); ray(ldir,0.35); ray(rdir,0.35);
      }

      CTX.restore();
    }
  }

  function roundRect(ctx,x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  // ---------- Q-learning Agent ----------
  class QTable{
    constructor(){ this.map = new Map(); }
    key(obs){
      // bits: danger(3) | dir(2) | fq(2)
      const b = (obs.dangerL&1) | ((obs.dangerF&1)<<1) | ((obs.dangerR&1)<<2) | ((obs.dir&3)<<3) | ((obs.fq&3)<<5);
      return b;
    }
    getQ(obs){
      const k=this.key(obs);
      let row = this.map.get(k);
      if (!row){ row = new Float32Array([0,0,0]); this.map.set(k,row); }
      return row;
    }
    update(obs,a,target,alpha){
      const row = this.getQ(obs);
      row[a] = row[a] + alpha*(target - row[a]);
    }
  }
  class Agent{
    constructor(cfg){ this.cfg = cfg; }
    reset(totalSteps=0){
      this.Q = new QTable();
      this.totalSteps = totalSteps;
      this.eps = this.cfg.epsStart;
      this.returns = [];
      this.ma100 = 0;
    }
    epsilon(){
      const {epsStart,epsEnd,epsDecay} = this.cfg;
      const t = clamp(this.totalSteps/epsDecay,0,1);
      this.eps = epsStart + (epsEnd - epsStart)*t;
      return this.eps;
    }
    act(obs){
      const eps = this.epsilon();
      if (Math.random() < eps) return (Math.random()*3|0);
      const q = this.Q.getQ(obs);
      return (q[1]>=q[0] && q[1]>=q[2])?1 : (q[2]>=q[0] && q[2]>=q[1])?2 : 0;
    }
    learn(obs,a,r,nextObs,done){
      const {alpha,gamma} = this.cfg;
      const qNext = this.Q.getQ(nextObs);
      const maxNext = done ? 0 : Math.max(qNext[0],qNext[1],qNext[2]);
      const target = r + gamma * maxNext;
      this.Q.update(obs,a,target,alpha);
    }
  }

  // ---------- Orchestrator ----------
  let env=null, agent=null, episode=0, epReturn=0, returns=[];
  function build(){
    const cfg = readConfig();
    env = new SnakeEnv(cfg);
    agent = new Agent(cfg);
    agent.reset(0);
    episode = 0; epReturn=0; returns=[];
    updateHUD();
    env.draw();
  }

  function start(){
    if (running) return;
    running=true;
    lastTick=performance.now(); lastSpsT=lastTick; acc=0; stepsThisSecond=0;
    loop();
  }
  function pause(){ running=false; if (timer) { cancelAnimationFrame(timer); timer=null; } }
  function stepOnce(){ tick(); }
  function resetAll(){ pause(); build(); }
  function calcHz(){ return clamp(parseInt(ids.speed.value)||20,1,120); }

  function loop(){
    if (!running) return;
    timer = requestAnimationFrame(loop);
    const now = performance.now();
    const dt = (now-lastTick)/1000; lastTick=now;
    acc += dt;
    const spf = 1/calcHz();
    while (acc >= spf){
      tick();
      acc -= spf;
    }
    // SPS
    if (now-lastSpsT >= 1000){
      sps = stepsThisSecond; stepsThisSecond=0; lastSpsT=now;
      ids.sps.textContent = sps.toString();
    }
  }

  function tick(){
    // live config
    env.cfg.wrap = !ids.wallsKill.checked;
    env.cfg.showSensors = ids.showSensors.checked;
    env.cfg.maxSteps = parseInt(ids.maxSteps.value)||env.cfg.maxSteps;
    env.cfg.starveSteps = parseInt(ids.starveSteps.value)||env.cfg.starveSteps;
    env.cfg.rFruit = parseFloat(ids.rFruit.value)||env.cfg.rFruit;
    env.cfg.rDeathSelf = parseFloat(ids.rDeathSelf.value)||env.cfg.rDeathSelf;
    env.cfg.rDeathWall = parseFloat(ids.rDeathWall.value)||env.cfg.rDeathWall;
    env.cfg.rStep = parseFloat(ids.rStep.value)||env.cfg.rStep;
    env.cfg.rDist = parseFloat(ids.rDist.value)||env.cfg.rDist;
    env.cfg.rStraight = parseFloat(ids.rStraight.value)||env.cfg.rStraight;
    env.cfg.clip = ids.clip.checked;
    agent.cfg.alpha = parseFloat(ids.alpha.value)||agent.cfg.alpha;
    agent.cfg.gamma = parseFloat(ids.gamma.value)||agent.cfg.gamma;
    agent.cfg.epsStart = parseFloat(ids.epsStart.value)||agent.cfg.epsStart;
    agent.cfg.epsEnd = parseFloat(ids.epsEnd.value)||agent.cfg.epsEnd;
    agent.cfg.epsDecay = parseInt(ids.epsDecay.value)||agent.cfg.epsDecay;

    const obs = env.observe();
    const aIdx = agent.act(obs);                  // 0,1,2
    const action = ACTS[aIdx];                    // -1,0,1
    const {obs:nextObs, reward, done} = env.step(action);
    agent.learn(obs, aIdx, reward, nextObs, done);
    agent.totalSteps++; epReturn += reward; stepsThisSecond++;

    if (done){
      episode++;
      ids.lastEnd.textContent = env.lastEndCause;
      returns.push(epReturn);
      if (returns.length>100) returns.shift();
      const avg = returns.reduce((a,b)=>a+b,0)/Math.max(1,returns.length);
      agent.ma100 = avg;
      env.reset();
      epReturn=0;
      updateHUD();
    } else {
      updateHUD(false);
    }
    env.draw();
  }

  function updateHUD(full=true){
    if (full){
      ids.ep.textContent = episode.toString();
      ids.avgR.textContent = (agent.ma100||0).toFixed(2);
      ids.score.textContent = env.score.toString();
    }
    ids.step.textContent = env.steps.toString();
    ids.len.textContent = env.snake.length.toString();
    ids.eps.textContent = (agent?agent.eps:1).toFixed(2);
  }

  // ---------- UI wiring ----------
  ids.btnRun.onclick = () => start();
  ids.btnPause.onclick = () => pause();
  ids.btnStep.onclick = () => stepOnce();
  ids.btnReset.onclick = () => { resetAll(); };
  ids.btnDefaults.onclick = () => { setDefaults(); resetAll(); };

  // Rebuild env when board dims or seed change
  [ids.w, ids.h, ids.seed].forEach(el => el.addEventListener('change', ()=> resetAll()));

  // Redraw on layout/size changes (keeps 95% scale honored)
  const ro = new ResizeObserver(()=> env && env.draw());
  ro.observe(CV.parentElement || CV);

  // init
  setDefaults();
  build();

})();
</script>
</body>
</html>
